{"ast":null,"code":"const fs = require('fs');\nconst path = require('path');\nexports.contains = function contains(arr, val) {\n  return arr && arr.indexOf(val) !== -1;\n};\nconst atPrefix = new RegExp('^@', 'g');\nexports.readDir = function readDir(dirName) {\n  if (!fs.existsSync(dirName)) {\n    return [];\n  }\n  try {\n    return fs.readdirSync(dirName).map(function (module) {\n      if (atPrefix.test(module)) {\n        // reset regexp\n        atPrefix.lastIndex = 0;\n        try {\n          return fs.readdirSync(path.join(dirName, module)).map(function (scopedMod) {\n            return module + '/' + scopedMod;\n          });\n        } catch (e) {\n          return [module];\n        }\n      }\n      return module;\n    }).reduce(function (prev, next) {\n      return prev.concat(next);\n    }, []);\n  } catch (e) {\n    return [];\n  }\n};\nexports.readFromPackageJson = function readFromPackageJson(options) {\n  if (typeof options !== 'object') {\n    options = {};\n  }\n  const includeInBundle = options.exclude || options.includeInBundle;\n  const excludeFromBundle = options.include || options.excludeFromBundle;\n\n  // read the file\n  let packageJson;\n  try {\n    const fileName = options.fileName || 'package.json';\n    const packageJsonString = fs.readFileSync(path.resolve(process.cwd(), fileName), 'utf8');\n    packageJson = JSON.parse(packageJsonString);\n  } catch (e) {\n    return [];\n  }\n  // sections to search in package.json\n  let sections = ['dependencies', 'devDependencies', 'peerDependencies', 'optionalDependencies'];\n  if (excludeFromBundle) {\n    sections = [].concat(excludeFromBundle);\n  }\n  if (includeInBundle) {\n    sections = sections.filter(function (section) {\n      return [].concat(includeInBundle).indexOf(section) === -1;\n    });\n  }\n  // collect dependencies\n  const deps = {};\n  sections.forEach(function (section) {\n    Object.keys(packageJson[section] || {}).forEach(function (dep) {\n      deps[dep] = true;\n    });\n  });\n  return Object.keys(deps);\n};\nexports.containsPattern = function containsPattern(arr, val) {\n  return arr && arr.some(function (pattern) {\n    if (pattern instanceof RegExp) {\n      return pattern.test(val);\n    } else if (typeof pattern === 'function') {\n      return pattern(val);\n    } else {\n      return pattern == val;\n    }\n  });\n};\nexports.validateOptions = function (options) {\n  options = options || {};\n  const results = [];\n  const mistakes = {\n    allowlist: ['allowslist', 'whitelist', 'allow'],\n    importType: ['import', 'importype', 'importtype'],\n    modulesDir: ['moduledir', 'moduledirs'],\n    modulesFromFile: ['modulesfile'],\n    includeAbsolutePaths: ['includeAbsolutesPaths'],\n    additionalModuleDirs: ['additionalModulesDirs', 'additionalModulesDir']\n  };\n  const optionsKeys = Object.keys(options);\n  const optionsKeysLower = optionsKeys.map(function (optionName) {\n    return optionName && optionName.toLowerCase();\n  });\n  Object.keys(mistakes).forEach(function (correctTerm) {\n    if (!options.hasOwnProperty(correctTerm)) {\n      mistakes[correctTerm].concat(correctTerm.toLowerCase()).forEach(function (mistake) {\n        const ind = optionsKeysLower.indexOf(mistake.toLowerCase());\n        if (ind > -1) {\n          results.push({\n            message: `Option '${optionsKeys[ind]}' is not supported. Did you mean '${correctTerm}'?`,\n            wrongTerm: optionsKeys[ind],\n            correctTerm: correctTerm\n          });\n        }\n      });\n    }\n  });\n  return results;\n};\nexports.log = function (message) {\n  console.log(`[webpack-node-externals] : ${message}`);\n};\nexports.error = function (errors) {\n  throw new Error(errors.map(function (error) {\n    return `[webpack-node-externals] : ${error}`;\n  }).join('\\r\\n'));\n};","map":{"version":3,"names":["fs","require","path","exports","contains","arr","val","indexOf","atPrefix","RegExp","readDir","dirName","existsSync","readdirSync","map","module","test","lastIndex","join","scopedMod","e","reduce","prev","next","concat","readFromPackageJson","options","includeInBundle","exclude","excludeFromBundle","include","packageJson","fileName","packageJsonString","readFileSync","resolve","process","cwd","JSON","parse","sections","filter","section","deps","forEach","Object","keys","dep","containsPattern","some","pattern","validateOptions","results","mistakes","allowlist","importType","modulesDir","modulesFromFile","includeAbsolutePaths","additionalModuleDirs","optionsKeys","optionsKeysLower","optionName","toLowerCase","correctTerm","hasOwnProperty","mistake","ind","push","message","wrongTerm","log","console","error","errors","Error"],"sources":["C:/Users/szymo/OneDrive/Desktop/Coding/AI_Image_Generator/recipe_generator/node_modules/webpack-node-externals/utils.js"],"sourcesContent":["const fs = require('fs');\r\nconst path = require('path');\r\n\r\nexports.contains = function contains(arr, val) {\r\n    return arr && arr.indexOf(val) !== -1;\r\n};\r\n\r\nconst atPrefix = new RegExp('^@', 'g');\r\nexports.readDir = function readDir(dirName) {\r\n    if (!fs.existsSync(dirName)) {\r\n        return [];\r\n    }\r\n\r\n    try {\r\n        return fs\r\n            .readdirSync(dirName)\r\n            .map(function (module) {\r\n                if (atPrefix.test(module)) {\r\n                    // reset regexp\r\n                    atPrefix.lastIndex = 0;\r\n                    try {\r\n                        return fs\r\n                            .readdirSync(path.join(dirName, module))\r\n                            .map(function (scopedMod) {\r\n                                return module + '/' + scopedMod;\r\n                            });\r\n                    } catch (e) {\r\n                        return [module];\r\n                    }\r\n                }\r\n                return module;\r\n            })\r\n            .reduce(function (prev, next) {\r\n                return prev.concat(next);\r\n            }, []);\r\n    } catch (e) {\r\n        return [];\r\n    }\r\n};\r\n\r\nexports.readFromPackageJson = function readFromPackageJson(options) {\r\n    if (typeof options !== 'object') {\r\n        options = {};\r\n    }\r\n    const includeInBundle = options.exclude || options.includeInBundle;\r\n    const excludeFromBundle = options.include || options.excludeFromBundle;\r\n\r\n    // read the file\r\n    let packageJson;\r\n    try {\r\n        const fileName = options.fileName || 'package.json';\r\n        const packageJsonString = fs.readFileSync(\r\n            path.resolve(process.cwd(), fileName),\r\n            'utf8'\r\n        );\r\n        packageJson = JSON.parse(packageJsonString);\r\n    } catch (e) {\r\n        return [];\r\n    }\r\n    // sections to search in package.json\r\n    let sections = [\r\n        'dependencies',\r\n        'devDependencies',\r\n        'peerDependencies',\r\n        'optionalDependencies',\r\n    ];\r\n    if (excludeFromBundle) {\r\n        sections = [].concat(excludeFromBundle);\r\n    }\r\n    if (includeInBundle) {\r\n        sections = sections.filter(function (section) {\r\n            return [].concat(includeInBundle).indexOf(section) === -1;\r\n        });\r\n    }\r\n    // collect dependencies\r\n    const deps = {};\r\n    sections.forEach(function (section) {\r\n        Object.keys(packageJson[section] || {}).forEach(function (dep) {\r\n            deps[dep] = true;\r\n        });\r\n    });\r\n    return Object.keys(deps);\r\n};\r\n\r\nexports.containsPattern = function containsPattern(arr, val) {\r\n    return (\r\n        arr &&\r\n        arr.some(function (pattern) {\r\n            if (pattern instanceof RegExp) {\r\n                return pattern.test(val);\r\n            } else if (typeof pattern === 'function') {\r\n                return pattern(val);\r\n            } else {\r\n                return pattern == val;\r\n            }\r\n        })\r\n    );\r\n};\r\n\r\nexports.validateOptions = function (options) {\r\n    options = options || {};\r\n    const results = [];\r\n    const mistakes = {\r\n        allowlist: ['allowslist', 'whitelist', 'allow'],\r\n        importType: ['import', 'importype', 'importtype'],\r\n        modulesDir: ['moduledir', 'moduledirs'],\r\n        modulesFromFile: ['modulesfile'],\r\n        includeAbsolutePaths: ['includeAbsolutesPaths'],\r\n        additionalModuleDirs: ['additionalModulesDirs', 'additionalModulesDir'],\r\n    };\r\n    const optionsKeys = Object.keys(options);\r\n    const optionsKeysLower = optionsKeys.map(function (optionName) {\r\n        return optionName && optionName.toLowerCase();\r\n    });\r\n    Object.keys(mistakes).forEach(function (correctTerm) {\r\n        if (!options.hasOwnProperty(correctTerm)) {\r\n            mistakes[correctTerm]\r\n                .concat(correctTerm.toLowerCase())\r\n                .forEach(function (mistake) {\r\n                    const ind = optionsKeysLower.indexOf(mistake.toLowerCase());\r\n                    if (ind > -1) {\r\n                        results.push({\r\n                            message: `Option '${optionsKeys[ind]}' is not supported. Did you mean '${correctTerm}'?`,\r\n                            wrongTerm: optionsKeys[ind],\r\n                            correctTerm: correctTerm,\r\n                        });\r\n                    }\r\n                });\r\n        }\r\n    });\r\n    return results;\r\n};\r\n\r\nexports.log = function (message) {\r\n    console.log(`[webpack-node-externals] : ${message}`);\r\n};\r\n\r\nexports.error = function (errors) {\r\n    throw new Error(\r\n        errors\r\n            .map(function (error) {\r\n                return `[webpack-node-externals] : ${error}`;\r\n            })\r\n            .join('\\r\\n')\r\n    );\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}